# 中断

本指南适用于想构建高可用应用程序的应用所有者，因此需要了解Pod可能发生的中断。这也适用于希望集群执行自动操作的集群管理员，例如升级和自动缩放群集。

## 自愿和非自愿中断

Pod不会消失，除非有人（人或控制器）摧毁他们，或者发生了不可避免的硬件或系统错误。

我们将这些不可避免的场景称为对应用程序的*非自愿中断* 。例如：

- 支持节点的物理机发生硬件故障。
- 系统管理员错误的删除了虚拟机。
- 云供应商或超级线程错误导致虚拟机小时。
- 内核恐慌。
- 由于集群网络分区导致节点从集群消失。
- 由于节点资源不足而导致pod被驱逐。

除资源不足外，大多数用户都应熟悉所有这些条件; 它们不是Kubernetes特有的。我们把其他场景称为*自愿中断* 。自愿中断包括应用程序所有者启动的操作和集群管理员启动的操作。应用所有者典型的操作包括：

- 删除deployment或其他管理pod的控制器。
- 更新pod的deployment导致重启。
- 直接删除pod。

集群管理员的操作包括：

- 排空节点进行修复或升级。
- 从集群中排除节点来对集群缩容。
- 从节点移除Pod来保证其他Pod可以部署在该节点。

这些动作可能是集群管理员直接操作，也可能是由管理员允许的自动化执行，或者集群的托管供应商执行。咨询您的集群管理员或咨询您的云提供商或分发文档，以确定是否为您的集群启用了任何自愿中断源。如果没有启用任何自愿中断，你可以跳过Pod中断的预算。

> **警告**：不是所有的自愿中断都受 Pod Disruption Budgets约束。例如，删除deployment或pod会绕过Pod Disruption Budgets。

## 处理中断

以下是一些缓解非自愿中断的方法：

- 确保Pod需要的资源。
- 如果你需要更高的可靠性，对应用进行备份。
- 为了在运行复制的应用程序时获得更高的可用性，应用程序可以跨机架（使用亲和反亲和性）或跨区（跨区集群）部署。

自愿中断的频率各不相同。在基本的Kubernetes集群上，根本不存在自愿中断。但是，集群管理员和集群托管商可能运行额外的服务而导致自愿中断。例如：节点软件滚动升级可能导致自愿中断。此外，集群自动扩容的实现可能导致自愿中断。 您的集群管理员或托管服务提供商应记录预期的自愿中断级别（如果有的话）。Kubernetes提供的功能可以帮助您在频繁的自愿中断的同时运行高可用性应用程序。 我们将这组功能称为*中断预算*。

## PDB如何工作

------

应用程序所有者可以为每个应用程序创建一个`PodDisruptionBudget`对象（PDB）。PDB限制由于自愿中断导致的应用程序同时下线的Pod数量。例如，基于仲裁的应用程序希望确保运行的副本数量永远不会低于仲裁所需的数量。Web前端可能希望确保服务负载的副本数量永远不会低于总数的某个百分比。

集群管理器和集群供应商应该使用遵守Pod Disruption Budget的工具，工具通过调用`Eviction API`  而不是直接删除pod或deployment。例如，使用 `kubectl drain` 命令行工具，在 Kubernetes-on-GCE 集群上可以使用升级脚本`(cluster/gce/upgrade.sh)`

当集群管理员想排除一个节点时，管理员应该使用`kubectl drain` 命令，工具会尝试驱逐机器上的所有pod。Pod驱逐请求可能被暂时拒绝，工具会周期性的尝试失败的请求直到所有的pod被停止或达到配置的超时间。

PDB指定的是应用程序可以容忍的副本数量，相对于预期的副本数量。例如，deployment中的 `.spec.replicas: 5` 字段希望在任何时刻都有5个Pod，如果它的PDB允许在某个时刻有4个Pod，那么Eviction API在某一时刻允许一个pod自愿中断，但是不允许两个pod自愿中断。

构成应用的一组pod由标签选择器选择，这和应用的控制器（deployment、stateful-set等）选择pod是一样的。

期望pod的数量是由pod控制器的 `.spec.replicas`  字段计算。Pod使用对象的`.metadata.ownerReferences` 发现控制器。

PDB不能防止非自愿中断发生，但它们确实违背了预算。

由于应用程序滚动升级导致pod被删除或不可用，确实会被记录到中断预算中，但是在滚动升级时控制器不受PDB的限制，在滚动升级过程中错误的处理是在控制器的spec中定义。

当使用驱逐API来驱逐一个pod时，pod可以被优雅的停止。

## PDB 样例

考虑一个由三个节点`node-1`、`node-2`和`node-3`组成的集群，有多个应用运行在集群中。其中一个应用有三个副本`pod-a`、`pod-b`和`pod-c`。还有一个不涉及PDB的pod称为`pod-x` ，初始，pod的部署如下表所示：

| node-1            | node-2            | node-3            |
| :---------------- | :---------------- | :---------------- |
| pod-a *available* | pod-b *available* | pod-c *available* |
| pod-x *available* |                   |                   |

`pod-a`、`pod-b`和`pod-c`这三个pod是deployment的一部分，而且deployment有一个PDB要求在任何时刻三个pod中至少有两个pod可用。

举个例子，集群管理员想重置内核到新的版本以修复内核错误。集群管理员首先尝试使用`kbuectl drain` 命令排除`node-1` 。`kubectl` 工具尝试驱逐`pod-a`和`pod-x` ，这个操作将会立即成功。pod-a和pod-x会同时进入terminating状态，集群的状态如下：

| node-1 *draining*   | node-2            | node-3            |
| :------------------ | :---------------- | :---------------- |
| pod-a *terminating* | pod-b *available* | pod-c *available* |
| pod-x *terminating* |                   |                   |

deployment会注意到有一个pod正在停止，因此deployment会创建`pod-d`来代替`pod-a`。由于`node-1`已经被封锁，因此deployment将`pod-d`部署在另外的节点上。同样的，`pod-y`会被创建来取代`pod-x`。

(注意：对于`StatefulSet`来说，`pod-a`可能被叫做`pod-1`，`StatefulSet`要保证所有pod按顺序编号，只有在完全停止时才能被新的pod代替，而且新的pod也叫`pod-1`，但是UID会编号，其他方面都是一致的)

现在集群的状态如下:

| node-1 *draining*   | node-2            | node-3            |
| :------------------ | :---------------- | :---------------- |
| pod-a *terminating* | pod-b *available* | pod-c *available* |
| pod-x *terminating* | pod-d *starting*  | pod-y             |

在某个时间点，pod已经终止，集群的状态可能如下：

| node-1 *drained* | node-2            | node-3            |
| :--------------- | :---------------- | :---------------- |
|                  | pod-b *available* | pod-c *available* |
|                  | pod-d *starting*  | pod-y             |

在这个时间点，如果是一位不够耐心的集群管理员尝试排除node-2或node-3,，由于deployment当前只有2个可用的pod，而且PDB要求有2个可用pod，因此drain命令会被阻塞。

集群现在的状态可能是这样的：

| node-1 *drained* | node-2            | node-3            |
| :--------------- | :---------------- | :---------------- |
|                  | pod-b *available* | pod-c *available* |
|                  | pod-d *available* | pod-y             |

现在，集群管理员尝试排除`node-2` 。排除命令尝试驱逐部署在node-2上面的两个pod，驱逐的顺序假设为先`pod-b`然后驱逐`pod-d`。驱逐`pod-b`将会成功，但是当尝试驱逐`pod-d`会被拒绝，因为deployment只有1个可用的pod，但是PDB要求最少2个。

deployment为pod-b创建一个替代pod-e。但是因为集群没有足够的资源来调度pod，排除命令将会再一次被阻塞，集群最终的状态可能如下：

| node-1 *drained* | node-2            | node-3            | *no node*       |
| :--------------- | :---------------- | :---------------- | :-------------- |
|                  | pod-b *available* | pod-c *available* | pod-e *pending* |
|                  | pod-d *available* | pod-y             |                 |

此时，集群管理员需要将节点添加回集群以继续升级。

根据以下条件，你可以看到Kubernetes如何改变中断发生的速度：

- 一个应用需要多少副本
- 由于停止一个实例需要的时间
- 启动一个新实例需要的时间
- 控制器的类型
- 集群资源容量

## 分离群集所有者和应用程序所有者角色

通常，将群集管理器和应用程序所有者视为彼此知之甚少的单独角色很有用。 在这些情况下，这种职责分离可能有意义：

- 当有多个应用团队共享一个Kubernetes集群时，角色分离是一件非常自然的事情。
- 当使用第三方工具或服务来自动管理集群时。

Pod Disruption Budgets通过在角色之间提供接口来支持这种角色分离。如果您的组织中没有这样的责任分离，可能不需要使用Pod Disruption Budgets。

## 如何在群集上执行中断操作

如果您是群集管理员，并且需要对群集中的所有节点执行中断操作，例如节点或系统软件升级，则可以使用以下选项：

- 升级期间接受停机。
- 故障转移到另一个完整的副本群集。
  - 无停机，但是需要双倍的节点以及需要人工切换。
- 构建支持中断的应用并且使用PDBs
  - 无停机。
  - 最小资源冗余。
  - 支持集群管理的高度自动化。
  - 编写中断容错的应用非常棘手，但是，容忍自愿中断的工作在很大程度上与支持自动调节和容忍非自愿中断的工作重叠
