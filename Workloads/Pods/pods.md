# Pods

Pod是Kubernetes中创建和管理的最小的、可部署计算单元。

## 什么是 Pod?

一个pod是一组一个或多个容器，容器共享存储和网络，拥有如何运行容器的规范。Pod的内容始终共地址并共同调度，并在共享的上下文中运行。Pod模拟特定于应用程序的逻辑主机，Pod包含一个或多个相对紧密耦合的应用程序容器，在前容器时代，在同一物理机或虚拟机上执行意味着在同一逻辑主机上执行。

虽然Kubernetes支持更多的容器运行时，不仅仅是Docker。但是Docker是最为熟知的容器运行时，这有助于使用Docker术语来描述pod。

pod的共享上下文是一组Linux命名空间，cgroup，以及可能的隔离方面 - 与隔离Docker容器相同的东西。在Pod上下文内，应用程序可能应用进一步的子隔离。

同一个Pod内的容器共享IP地址和端口空间，并且可以使用`localhost` 找到对方。容器还可以使用标准的进程间通信方法（如SystemV信号量或POSIX共享内存）相互通信。不同Pod内的容器拥有不同的IP地址，在没有特殊配置的情况下不能通过IPC通信。不同Pod内容器间的痛惜通常通过Pod IP地址。

Pod中的应用程序也可以访问共享卷，共享卷被定义为pod的一部分，可以挂载到每个应用程序的文件系统中。

就构建Docker而言，pod被建模为一组具有共享命名空间和共享卷的Docker容器。

和单应用容器一样，pod也被认为是相对短暂的实体（非持久实体）。正如在pod生命周期中所讨论的，创建pod，给pod分配唯一的UUID，并将pod调度到节点上，pod将一直在该节点知道pod被终止（根据设置的重启策略）或删除。如果一个节点死掉，超时时间过后，调度到该节点的pod会被删除。

当说起一些东西和pod拥有相同的生命时，比如存储，这也就是说只要pod存储，存储卷就会一直存在。不管因为什么原因pod被删除，及时使用不同UID的pod替换了原来的pod，与pod相关的东西（比如存储卷）也都会被删除并重新创建。

![img](https://d33wubrfki0l68.cloudfront.net/aecab1f649bc640ebef1f05581bfcc91a48038c4/728d6/images/docs/pod.svg)



### pod diagram

一个多容器pod，包含一个`file puller` and a `web server` 两个容器共享存储。

## Pods 的动机

### 管理

Pod是多个进程合作形成一个有凝聚力的服务单元的模型。Pod通过提供比其组成应用程序集更高级别的抽象来简化应用程序的部署和管理。Pod是部署、水平扩展和副本的基本单元。对于Pod中的容器，将自动处理共置（共同调度），共享命运（例如终止），协调复制，资源共享和依赖关系管理。

### 资源共享和通信

Pod可以实现其成员之间的数据共享和通信。

一个Pod内的应用程序使用相同的网络命名空间（相同的IP和端口），因此应用程序可以使用`localhost` 发现彼此并相互通信。因此，Pod内的应用程序之间必须协调端口的使用。在扁平的共享网络空间内每个Pod都有一个IP地址，可以通过网络和其他物理机和Pod通信。

主机名设置为pod中应用程序容器的pod名称。

除了定义在pod中运行的应用程序容器之外，pod还指定了一组共享存储卷。卷使数据能够在容器重新启动后继续存在，并在容器内的应用程序之间共享。

## 使用 pods

Pod可用于托管垂直集成的应用程序栈（例如LAMP），但其主要动机是支持共址，共同管理的帮助程序，例如：

- 内容管理系统，文件和数据加载器，本地缓存管理器等等。
- 日志和检查点备份，压缩，旋转，快照等。
- 数据变更观察，日志跟踪，日志和监控适配器，事件发布者等。
- 代理，桥和适配器。
- 控制器，管理器，配置器和更新程序。

一般情况下一个Pod不会允许应用程序的多个实例。

## 可替代方案

为什么不在一个容器内允许多个进程?

1. 透明度。 使Pod内的容器对基础设施可见，以使基础设施能够为这些容器提供服务，例如进程管理和资源监视。 这为用户提供了许多便利。
2. 解耦软件依赖。容器可以独立地进行版本化，重建和重新部署。 Kubernetes甚至有一天可能会支持单个容器的实时更新。
3. 使用更简单。用户不需要运行自己的进程管理器，无需担心信号和退出码传播等。
4. 更高效。基础设施承担了更多的责任，容器可以更加轻量化。

*为什么不支持基于亲缘关系的容器调度？*

这种方式虽然能够提供共址，但是不能提供pod带来的更多益处，比如资源共享、IPC，命运共享和简单的管理。

## Pods的持久性

Pod不会被当做持久实体对待。Pod不会在调度失败、节点失败或其他驱逐（资源不足、节点维护）中存活下来，

一般情况下，用户不需要直接创建pods。用户应该使用控制器即使只有单个pod，例如Deployment。控制器在集群范围内提供了自愈、复制、部署管理。像StatefulSet这样的控制器可以支持有状态pod。

使用集合API作为主要的面向用户的原语在集群调度系统中相对常见，包括Borg，Marathon，Aurora和Tupperware。

为了使用Pod以原语暴露：

- 调度器和控制器可插拔。
- 支持pod级操作，无需通过控制器API“代理”它们。
- pod生命周期与控制器生命周期的解耦，例如自引导。
- 控制器和服务的分离 - 端点控制器只是监视pod。
- 具有集群级功能的Kubelet级功能的清晰组合 -  Kubelet实际上是“pod控制器”。
- 高可用应用。

## 终止 Pods

由于Pod代表集群中运行在节点上的进程，当不在需要这些进程时允许进程优雅退出非常重要（而不是被KILL信号强制杀死而没有机会清理）。用户应该能够请求删除并知道进程何时终止，但也能够确保删除最终完成。当用户请求删除pod时，系统会记录允许的宽限期-pod被允许强制终止之前的周期。终止信号会发送到所有容器内的主进程。一旦超过宽限期，终止信号会发给这些进程，并从API server上删除pod。如果在等待进程终止期间kubelet或容器管理器正在重启，终止动作将会以完整的宽限期进行重试。

一个实例流程:

1. 用户发送命令删除Pod，默认宽限期（30秒）。
2. API服务器中的Pod随着时间的推移而更新，在宽限期内，Pod被认为“死亡”。
3. 当使用客户端工具查看Pod时，Pod呈现的状态为“终止”。
4. 当Kubelet看到Pod被标记为终止时，kubelet开始启动进程关闭。
   1. 如果Pod中的容器定义了 `preStop` 钩子，将在容器内部调用该钩子。如果宽限期结束后，钩子仍然在运行，将会以很小的宽限期（2秒）调用步骤二。
   2. 给容器发送TERM信号，注意不是Pod内所有的容器都可以同时收到TERM信号。如果容器关闭的顺序十分重要，每个容器可能都需要一个`preStop` 钩子。
5. 从service的端点列表中移除Pod，并且不再被看做是副本控制器存活集合的一个Pod。关闭非常慢的Pod在负载均衡器移除之前依然能够处理流量。
6. 当宽限期结束后，Pod内任何仍然在运行的经常都将被使用SIGKILL信号终止。
7. Kubelet通过设置宽限期为0从而将Pod从API server上删除Pod。Pod从API上移除后，客户端将不可见Pod。

默认删除Pod的宽限期为30秒，`kubectl delete` 命令支持使用 `--grace-period=<seconds>` 设置用户自定义的宽限期并覆盖默认值。当使用 0强制删除时，需要同时指定 `--grace-period=0` 来执行强制删除。 

### 强制删除 pods

强制删除Pod被定义为从集群状态和ETCD中立即删除。当执行一个强制删除时，apiserver不会等待kubelete已经确认从pod的节点中已经删除。Pod会立即从API中删除，因此新的Pod可以立即被创建。在Pod运行的节点上，pod不会被立即删除直到宽限期截止为止。

强制删除对于某些Pod来说是十分危险的，需要谨慎使用。对于有状态Pod，请参考 deleting Pods from a [StatefulSet](https://kubernetes.io/docs/tasks/run-application/force-delete-stateful-set-pod/) 文档操作。

## Pod容器的特权模式

从Kubernetes V1.1版本开始，通过 `privileged` 标记或容器 spec中的`SecurityContext` Pod内的任何容器都可以开启特权模式。这对于想利用诸如操作网络栈、访问设备等Linux操作系统能力的容器来说是非常有用的。容器内的进程几乎获得了和容器外进程一样的权限。在特权模式下，为独立的Pod编写网络和卷插件而不用编译到kublet中将更加简单。

如果主节点运行的Kubernetes版本等于或高于v1.1，但是节点允许的版本低于v1.1，新的特权模式下的pod可以被api-server接受，但是pod不会被启动。Pod将一直处于pending状态。使用`kubectl describe podname` 可以看到pod处于pending状态的原因，可能的错误信息如下：: `Error validating pod "FooPodName"."FooPodNamespace" from api, ignoring: spec.containers[0].securityContext.privileged: forbidden '<*>(0xc2089d3248)true'`

`如果主节点运行的kubernetes版本低于v1.1，特权模式的pod将不允许被创建。可能的错误信息如下： The Pod "FooPodName" is invalid. spec.containers[0].securityContext.privileged: forbidden '<*>(0xc20b222db0)true'`
